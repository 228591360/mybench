什么是多线程，多线程的优劣？
多线程：多线程是指程序中包含多个执行流，即在一个程序中可以同时运行多个不同的线程来执行不同的任务。

多线程的好处：
    可以提高 CPU 的利用率。在多线程程序中，一个线程必须等待的时候，CPU 可以运行其它的线程而不是等待，这样就大大提高了程序的效率。也就是说允许单个程序创建多个并行执行的线程来完成各自的任务。

多线程的劣势：
    线程也是程序，所以线程需要占用内存，线程越多占用内存也越多；
    多线程需要协调和管理，所以需要 CPU 时间跟踪线程；
    线程之间对共享资源的访问会相互影响，必须解决竞用共享资源的问题。

线程生命周期
    新建new -- 等待Cpu -- 运行start-- 阻塞 -- 死亡

守护线程和用户线程
    用户 (User) 线程：运行在前台，执行具体的任务，如程序的主线程、连接网络的子线程等都是用户线程
    守护 (Daemon) 线程：运行在后台，为其他前台线程服务。也可以说守护线程是 JVM 中非守护线程的 “佣人”。一旦所有用户线程都结束运行，守护线程会随 JVM 一起结束工作

什么是线程死锁
    死锁是指两个或两个以上的进程（线程）在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程（线程）称为死锁进程（线程）。

形成死锁的四个必要条件是什么
    互斥条件：线程(进程)对于所分配到的资源具有排它性，即一个资源只能被一个线程(进程)占用，直到被该线程(进程)释放
    请求与保持条件：一个线程(进程)因请求被占用资源而发生阻塞时，对已获得的资源保持不放。
    不剥夺条件：线程(进程)已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。
    循环等待条件：当发生死锁时，所等待的线程(进程)必定会形成一个环路（类似于死循环），造成永久阻塞

如何避免线程死锁
    我们只要破坏产生死锁的四个条件中的其中一个就可以了。

创建线程有哪几种方式？
    创建线程有四种方式：
        继承 Thread 类；
        实现 Runnable 接口；
        实现 Callable 接口；
        使用 Executors 工具类创建线程池

Runnable和Callable的区别
    Runnable没有返回值，Callable可以拿到返回值，Callable可以看做是Runnable的补充

线程的run（）和start（）的区别
    start（）方法用于启动线程；run（）方法用于执行线程的运行时代码
    run（）可以重复调用，而start（）只能调用一次

sleep()和wait()的区别
    sleep()来自Thread，wait()来自Object
    sleep()不需要释放锁，wait()需要释放锁
    sleep()时间到会自动恢复；wait()可以使用notify()/notifyAll()直接唤醒

notify和notifyAll的区别
    notify() 随机唤醒一个线程（具体哪个线程由虚拟机控制）
    notifyAll() 会唤醒所有的线程，

并行和并发的区别
    并行：多个处理器或多核处理器同时处理多个任务
    并发：多个任务在同一个CPU核上，一个处理器处理多个任务

synchronized和Lock的区别
    synchronized和Lock都是属于悲观锁
    synchronized可以给类、方法、代码块加锁；而Lock只能给代码块加锁
    synchronized不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁
    Lock需要自己加锁和释放锁，如果使用不当没有unLock()去释放锁就会造成死锁
    通过Lock可以知道有没有成功获取锁，而synchronized没法办到
    性能上面讲的话 Lock效率高一些

synchronized和volatile区别
    volatile是变量修饰符；synchronized是修饰类、方法、代码段
    volatile仅能实现变量的修改可见性，不能保证原子性；而synchronized则可以保证变量的修改可见性和原子性
    volatile不会造成线程的阻塞；synchronized可能会造成线程阻塞

ThreadLocal是什么？使用场景
    保证每个线程都访问自己的东西

    使用场景：数据库连接和session管理等
    ThreadLocal原理
    ThreadLocal 是线程的局部变量， 是每一个线程所单独持有的，其他线程不能对其进行访问

线程池四种创建方式
    Java通过Executors（jdk1.5并发包）提供四种线程池，分别为：
    newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。
        ExecutorService newExecutorService = Executors.newCachedThreadPool();

    newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。
        ExecutorService newExecutorService = Executors.newFixedThreadPool(3);

    newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。
         ScheduledExecutorService newScheduledThreadPool = Executors.newScheduledThreadPool(5);

    newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。
        ExecutorService newSingleThreadExecutor = Executors.newSingleThreadExecutor();

线程池有哪些参数
    1.corePoolSize:线程池中的常驻核心线程数

    在创建了线程池后，当有请求任务进来之后，就会安排池中的线程去执行请求任务，近似理解为今日当值线程

    当线程池中的线程数目达到corePoolSize后，就会把到达的任务放入缓存队列中。

    2.maximumPoolSize:线程池能够容纳同时执行的最大线程数，此值必须大于等于1

    3.keepAliveTime:多余的空闲线程的存活时间。

        当前线程池数量超过corePoolSize时，当空闲时间达到keepAliveTime值时，

        多余空闲线程会被销毁直到只剩下corePoolSize个线程为止

        默认情况下，只有当线程池中的线程数大于corePoolSize时，keepAliveTime才会起作用，直到线程池找那个的线程数不大于corePoolSize。

    4.unit:keepAliveTime的单位

    5.workQueue：任务队列，被提交但尚未被执行的任务

    6.threadFactory：表示生成线程池中工作线程的线程工厂，用于创建线程一般默认即可

    7.handler：拒绝策略，表示当队列满了并且工作线程大于等于线程池最大线程数（maximumPoolSize）时如何处理