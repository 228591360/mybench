简单说明spring如何解决循环依赖
    我们先实例化A，实例化好后，调用addSingletonFactory放入三级缓冲池中，然后此时我们设置属性的时候会发现我们还依赖B，于是我们就先去实例化B后并为进行属性赋值，而当我们进行赋值的时发现B也依赖A，
    但是之前已经把A存放在singletonFactories，那么B会将其取出并装配自己，实例化以后把自己放入单例池中，然后A也就可以继续进行属性赋值了，最后A 实例好以后，将自己也放入单例池中，这样Spring就解决了循环依赖。

讲讲Spring里面AOP的代理模式？jdk的代理模式和cglib的代理模式又啥区别？
    1）JDK动态代理：
        具体实现原理：
        1、通过实现InvocationHandler接口创建自己的调用处理器
        2、通过为Proxy类指定ClassLoader对象和一组interface来创建动态代理
        3、通过反射机制获取动态代理类的构造函数，其唯一参数类型就是调用处理器接口类型
        4、通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数参入
        JDK动态代理是面向接口的代理模式，如果被代理目标没有接口那么Spring也无能为力，
        Spring通过java的反射机制生产被代理接口的新的匿名实现类，重写了其中AOP的增强方法。

    2、CGLib动态代理
        CGLib是一个强大、高性能的Code生产类库，可以实现运行期动态扩展java类，Spring在运行期间通过 CGlib继承要被动态代理的类，重写父类的方法，实现AOP面向切面编程呢。

    区别：
        JDK动态代理需要使用接口的方式，是基于接口的，假如将以上JDK动态代理的例子中UserService这个接口去掉，直接写它的实现类，那么则会报错，因为必须要写接口
        cglib则不需要使用接口，是基于继承实现的，直接创建实现类即可，比如以上cglib动态代理的例子，无需写接口
        Spring的代理底层使用的就是这两种代理，可以根据需要，指定具体使用哪种代理生成机制（默认为JDK动态代理）
        基本规则是：目标业务类如果有接口则用JDK代理，没有接口则用CGLib代理
        JDK动态代理是面向接口，在创建代理实现类时比CGLib要快，创建代理速度快。
        CGLib动态代理是通过字节码底层继承要代理类来实现（如果被代理类被final关键字所修饰，那么抱歉会失败），在创建代理这一块没有JDK动态代理快，但是运行速度比JDK动态代理要快。

