Spring的AOP和IOC是什么？使用场景有哪些？
    AOP：面向切面编程。即在一个功能模块中新增其他功能  例如方法做日志
    IOC：依赖注入或者叫做控制反转。
        正常情况下我们使用一个对象时都是需要new Object()的。而ioc是把需要使用的对象提前创建好，放到spring的容器里面。
        所有需要使用的类都会在spring容器中登记，告诉spring你是个什么东西，你需要什么东西，然后spring会在系统运行到适当的时候，
        把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是spring。
IOC三种注入方式
    （1）XML：Bean实现类来自第三方类库，例如DataSource等。需要命名空间等配置，例如：context，aop，mvc。
    （2）注解：在开发的类使用@Controller，@Service等注解
    （3）Java配置类：通过代码控制对象创建逻辑的场景。例如：自定义修改依赖类库。

简单说明spring如何解决循环依赖
    我们先实例化A，实例化好后，调用addSingletonFactory放入三级缓冲池中，然后此时我们设置属性的时候会发现我们还依赖B，于是我们就先去实例化B后并为进行属性赋值，而当我们进行赋值的时发现B也依赖A，
    但是之前已经把A存放在singletonFactories，那么B会将其取出并装配自己，实例化以后把自己放入单例池中，然后A也就可以继续进行属性赋值了，最后A 实例好以后，将自己也放入单例池中，这样Spring就解决了循环依赖。

讲讲Spring里面AOP的代理模式？jdk的代理模式和cglib的代理模式又啥区别？
    1）JDK动态代理：
        具体实现原理：
        1、通过实现InvocationHandler接口创建自己的调用处理器
        2、通过为Proxy类指定ClassLoader对象和一组interface来创建动态代理
        3、通过反射机制获取动态代理类的构造函数，其唯一参数类型就是调用处理器接口类型
        4、通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数参入
        JDK动态代理是面向接口的代理模式，如果被代理目标没有接口那么Spring也无能为力，
        Spring通过java的反射机制生产被代理接口的新的匿名实现类，重写了其中AOP的增强方法。

    2、CGLib动态代理
        CGLib是一个强大、高性能的Code生产类库，可以实现运行期动态扩展java类，Spring在运行期间通过 CGlib继承要被动态代理的类，重写父类的方法，实现AOP面向切面编程呢。

    区别：
        JDK动态代理需要使用接口的方式，是基于接口的，假如将以上JDK动态代理的例子中UserService这个接口去掉，直接写它的实现类，那么则会报错，因为必须要写接口
        cglib则不需要使用接口，是基于继承实现的，直接创建实现类即可，比如以上cglib动态代理的例子，无需写接口
        Spring的代理底层使用的就是这两种代理，可以根据需要，指定具体使用哪种代理生成机制（默认为JDK动态代理）
        基本规则是：目标业务类如果有接口则用JDK代理，没有接口则用CGLib代理
        JDK动态代理是面向接口，在创建代理实现类时比CGLib要快，创建代理速度快。
        CGLib动态代理是通过字节码底层继承要代理类来实现（如果被代理类被final关键字所修饰，那么抱歉会失败），在创建代理这一块没有JDK动态代理快，但是运行速度比JDK动态代理要快。

