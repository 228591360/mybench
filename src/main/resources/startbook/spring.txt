简单说明spring如何解决循环依赖
    我们先实例化A，实例化好后，调用addSingletonFactory放入三级缓冲池中，然后此时我们设置属性的时候会发现我们还依赖B，于是我们就先去实例化B后并为进行属性赋值，而当我们进行赋值的时发现B也依赖A，
    但是之前已经把A存放在singletonFactories，那么B会将其取出并装配自己，实例化以后把自己放入单例池中，然后A也就可以继续进行属性赋值了，最后A 实例好以后，将自己也放入单例池中，这样Spring就解决了循环依赖。

dubbo spring cloud
如何设计一个高可用系统？  hystrix ->  限流 熔断 降级

hystrix是什么   ->  框架 提供了高可用相关的各种个样的功能 在hystrix的保护下，整个系统长期处于高可用的状态
    hystrix里面最核心的功能就是资源隔离，就是将多个依赖服务的调用分别隔离到各自的资源池内，避免说对某一个依赖服务的调用，因为依赖服务的接口的调用的延迟或者失败导致服务所有的线程资源全部耗费在这个服务上或者说被hang住，一旦全部资源耗尽，可能导致服务就会崩溃。

项目依赖
    <!-- https://mvnrepository.com/artifact/com.netflix.hystrix/hystrix-core -->
    <dependency>
        <groupId>com.netflix.hystrix</groupId>
        <artifactId>hystrix-core</artifactId>
        <version>1.5.18</version>
    </dependency>

hystrix的两种资源隔离技术
    1）线程池资源隔离 ThreadPoolExecutor ：适合99%的场景使用
    2）信号量资源隔离 semaphore
    核心区别：
    线程池和信号量做资源隔离、限流、容量的限制，默认的容量都是10

    Semaphore和线程池的区别如下：
    使用Semaphore，实际工作线程由开发者自己创建；使用线程池，实际工作线程由线程池创建
    使用Semaphore，并发线程的控制必须手动通过acquire()和release()函数手动完成；使用线程池，并发线程的控制由线程池自动管理
    使用Semaphore不支持设置超时和实现异步访问；使用线程池则可以实现超时和异步访问，通过提交一个Callable对象获得Future，从而可以在需要时调用Future的方法获得线程执行的结果，同样利用Future也可以实现超时