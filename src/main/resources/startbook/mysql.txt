MySQL常用引擎有 「 MyISAM和InnoDB 」，而InnoDB是mysql默认的引擎。

MyISAM和INNODB的区别
    1.事务安全：MyISAM不支持事务，INNODB支持
    2.查询和添加速度：MyISAM速度快，INNODB相对慢
    3.锁机制：MyISAM表锁，而InnoDB支持行锁和表锁。
    4.支持全文检索：MyISAM支持，INNODB不支持
    5.外建：MyISAM不支持，INNODB支持

建表优化
    字段尽量为not null
    int类型使用tinyint smallint
    能确定字符串长度的尽量使用char 而不是变长的varchar
    浮点型字段精度要求高的话用decimal 而不是double
    超长字符串使用text 尽量中从表关联

sql优化
    查询的字段避免用*号，指定需要的字段
    like使用右查询 like 'aa%' 放左边索引会失效
    使用join代替子查询
    使用union代替临时表
    使用索引
    读写分离
    主从复制
    分库分表

索引失效
     不等、空值、or like %放左索引失效变成全表扫描 字符串不见单引索引失效

什么是事务
     要么成功，要么失败，不可分割的一组操作

事物的特性
    原子性 一致性 隔离性 持久性

事物的隔离级别
    ru读未提交 、 rc读提交 、 rr可重复度、  SERIALIZABLE串行化 此隔离级别是四种隔离级别中最高的级别，解决了 「 脏读、可重复读、幻读 」 的问题。

MVCC 是什么：
   在读提交RC、可重复度RR的隔离级别下，MySQL的InnoDB存储引擎通过 MVCC (多版本并发控制) 机制来解决幻读。

使用MVCC时具体的体现是什么呢？
    使事务在并发过程中，SELECT 操作不用加锁，读写不冲突从而提高性能。

那么实现MVCC机制的原理是什么呢？
    其原理是通过保存数据在某个时间点的快照来实现的；通过在每行记录后面保存隐藏列来存放事务ID，这样每一个事务，都会对应一个递增的事务ID。

1。为什么分库分表 用过哪些分库分表的中间件  根据id hash取模路由   range分发（按时间段入库）
    分表
    　　比如你单表都几千万数据了，你确定你能扛住么？绝对不行，单表数据量太大，会极大影响你的 sql 执行的性能，到了后面你的 sql 可能就跑的很慢了。一般来说，就以我的经验来看，单表到几百万的时候，性能就会相对差一些了，你就得分表了。
    　　分表是啥意思？就是把一个表的数据放到多个表中，然后查询的时候你就查一个表。比如按照用户 id 来分表，将一个用户的数据就放在一个表中。然后操作的时候你对一个用户就操作那个表就好了。这样可以控制每个表的数据量在可控的范围内，比如每个表就固定在 200 万以内。

    分库
    　　分库是啥意思？就是你一个库一般我们经验而言，最多支撑到并发 2000，一定要扩容了，而且一个健康的单库并发值你最好保持在每秒 1000 左右，不要太大。那么你可以将一个库的数据拆分到多个库中，访问的时候就访问一个库好了。
    　　这就是所谓的分库分表，为啥要分库分表？你明白了吧。
    中间件 ：
        目前常用：sharding-jdbc（client 分发规则配置在配系统置文件）、
        mycat（proxy）  先在mycat官方网站上下载安装包  conf目录下编辑service.xml（主要配置mycat服务的参数，比如端口号，myact用户名和密码使用的逻辑数据库等），
                    rule.xml（主要配置路由策略，主要有分片的片键，拆分的策略 取模还是按区间划分等），schema.xml（文件主要配置数据库的信息）三个文件
        以前活跃：  cobar、 tddl 、 atlas


2。你们具体是如何对数据库进行垂直拆分或水平拆分的？

        水平拆分的意思，就是把一个表的数据给弄到多个库的多个表里去，但是每个库的表结构都一样，只不过每个库表放的数据是不同的，所有库表的数据加起来就是全部数据。
        水平拆分的意义，就是将数据均匀放更多的库里，然后用多个库来扛更高的并发，还有就是用多个库的存储容量来进行扩容。

    　　 垂直拆分的意思，就是把一个有很多字段的表给拆分成多个表，或者是多个库上去。每个库表的结构都不一样，每个库表都包含部分字段。一般来说，会将较少的访问频率很高的字段放到一个表里去，然后将较多的访问频率很低的字段放到另外一个表里去。
        因为数据库是有缓存的，你访问频率高的行字段越少，就可以在缓存里缓存更多的行，性能就越好。这个一般在表层面做的较多一些。

    两种分库分表的方式：

        一种是按照 range 来分，就是每个库一段连续的数据，这个一般是按比如时间范围来的，但是这种一般较少用，因为很容易产生热点问题，大量的流量都打在最新的数据上了。
        或者是按照某个字段 hash 一下均匀分散，这个较为常用。
        range 来分，好处在于说，扩容的时候很简单，因为你只要预备好，给每个月都准备一个库就可以了，到了一个新的月份的时候，自然而然，就会写新的库了；缺点，但是大部分的请求，都是访问最新的数据。实际生产用 range，要看场景。
        hash 分发，好处在于说，可以平均分配每个库的数据量和请求压力；坏处在于说扩容起来比较麻烦，会有一个数据迁移的过程，之前的数据需要重新计算 hash 值重新分配到不同的库或表。

3。如何不停机进行分库分表
    线上双写方案：修改系统中所有写库的代码 ，同时写入老库和新的分库分表的库，然后写个临时程序，同步老库到新库，如果发现数据冲突则检查update时间，最新数据覆盖老数据（写入分库分表中间件进行数据分发），再写个临时脚本去检查两边数据的一致性，如果没有一致则继续同步，
    最后同步完成把写入老库的代码删除重新部署，做到不停机分库分表。

4。MySQL主从复制原理
    为什么要做主从复制
        在业务复杂的系统中，有这么一个情景，有一句sql语句需要锁表，导致暂时不能使用读的服务，那么就很影响运行中的业务，使用主从复制，让主库负责写，从库负责读，这样，即使主库出现了锁表的情景，通过读从库也可以保证业务的正常运行。
        做数据的热备，主库宕机后能够及时替换主库，保证业务可用性。
        架构的扩展。业务量越来越大，I/O访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I/O访问的频率，提高单个机器的I/O性能。

    MySQL主从复制的流程 （如图：img/mysql主从复制流程.png）
        主库db的更新事件(update、insert、delete)被写到binlog
        主库创建一个binlog dump thread，把binlog的内容发送到从库
        从库启动并发起连接，连接到主库
        从库启动之后，创建一个I/O线程，读取主库传过来的binlog内容并写入到relay log
        从库启动之后，创建一个SQL线程，从relay log里面读取内容，从Exec_Master_Log_Pos位置开始执行读取到的更新事件，将更新内容写入到slave的db