MySQL常用引擎有 「 MyISAM和InnoDB 」，而InnoDB是mysql默认的引擎。

MyISAM和INNODB的区别
    1.事务安全：MyISAM不支持事务，INNODB支持
    2.查询和添加速度：MyISAM速度快，INNODB相对慢
    3.锁机制：MyISAM表锁，而InnoDB支持行锁和表锁。
    4.支持全文检索：MyISAM支持，INNODB不支持
    5.外建：MyISAM不支持，INNODB支持

建表优化
    字段尽量为not null
    int类型使用tinyint smallint
    能确定字符串长度的尽量使用char 而不是变长的varchar
    浮点型字段精度要求高的话用decimal 而不是double
    超长字符串使用text 尽量中从表关联

sql优化
    查询的字段避免用*号，指定需要的字段
    like使用右查询 like 'aa%' 放左边或者左右两边索引会失效（'%aa'、'%aa%'）
    使用join代替子查询
    使用union代替临时表
    使用索引
    读写分离
    主从复制
    分库分表

索引失效
     不等、空值、or、like %放左索引失效变成全表扫描 字符串不见单引索引失效

什么是事务
     要么成功，要么失败，不可分割的一组操作

事物的特性
    原子性（Atomicity）　　原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。
    一致性（Consistency） 事务前后数据的完整性必须保持一致。
    隔离性（Isolation）   事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。
    持久性（Durability）  持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响

事物的隔离级别
    ru读未提交 、 rc读提交 、 rr可重复度、  SERIALIZABLE串行化 此隔离级别是四种隔离级别中最高的级别，解决了 「 脏读、可重复读、幻读 」 的问题。

事务的七种传播行为
    什么是事务的传播行为:事务传播行为用来描述由某一个事务传播行为修饰的方法被嵌套进另一个方法的时事务如何传播。
    PROPAGATION_REQUIRED 表示当前方法必须在一个具有事务的 上下文中运行,如有客户端有事务在进行，那么被调用端将在该事务中运行，否则的话重新开启一个事务。( 如果被调用端发生异常,那么调用端和被调用端事务都将回滚)
    PROPAGATION_SUPPORTS 表示当前方法不必需要具有一个事务 上下文,但是如果有一个事务的话,它也可以在这个事务中运行
    PROPAGATION_MANDATORY 表示当前方法必须在一个事务中运行，如果没有事务，将抛出异常
    PROPAGATION_REQUIRES_NEW 总是开启一个新的事务。如果一个事务已经存在，则将这个存在的事务挂起。
    PROPAGATION_NOT_SUPPORTED 总是非事务地执行，并挂起任何存在的事务。
    PROPAGATION_NEVER 总是非事务地执行，如果存在一个活动事务，则抛出异常
    PROPAGATION_NESTED表示如果当前方法正有一个事务在运行中,则该方法应该运行在一个嵌套事务中 ,被嵌套的事务可以独立于被封装的事务中进行提交或者回滚。如果封装事务存在,并且外层事务抛出异常回滚，那么内层事务必须回滚,反之,内层事务并不影响外层事务。如果封装事务不存在,则同propagation. required的一样

MVCC 是什么：
   在读提交RC、可重复度RR的隔离级别下，MySQL的InnoDB存储引擎通过 MVCC (多版本并发控制) 机制来解决幻读。

使用MVCC时具体的体现是什么呢？
    使事务在并发过程中，SELECT 操作不用加锁，读写不冲突从而提高性能。

那么实现MVCC机制的原理是什么呢？
    其原理是通过保存数据在某个时间点的快照来实现的；通过在每行记录后面保存隐藏列来存放事务ID，这样每一个事务，都会对应一个递增的事务ID。

说一下乐观锁和悲观锁？
    乐观锁：每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。      使用场景：乐观锁只用在高并发、多读少写的场景。
    悲观锁：每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻止，直到这个锁被释放。      使用场景：数据库的行锁、表锁等，适用于数据一致性比较高的场景

    数据库的乐观锁需要自己实现，在表里面添加一个 version 字段，每次修改成功值加 1，这样每次修改的时候先对比一下，自己拥有的 version 和数据库现在的 version 是否一致，如果不一致就不修改，这样就实现了乐观锁。

什么是线程死锁
    两个事务都持有对方需要的锁，并且在等待对方释放，并且双方都不会释放自己的锁

MySQL 如何处理死锁？
    等待，直到超时（innodb_lock_wait_timeout=50s）。
    发起死锁检测，主动回滚一条事务，让其他事务继续执行（innodb_deadlock_detect=on）。
    由于性能原因，一般都是使用死锁检测来进行处理死锁。

如何避免发生死锁
    使用事务
    保证没有长事务
    操作完之后立即提交事务
    创建索引，可以使创建的锁更少


1。为什么分库分表 用过哪些分库分表的中间件  根据id hash取模路由   range分发（按时间段入库）
    分表
    　　比如你单表都几千万数据了，你确定你能扛住么？绝对不行，单表数据量太大，会极大影响你的 sql 执行的性能，到了后面你的 sql 可能就跑的很慢了。一般来说，就以我的经验来看，单表到几百万的时候，性能就会相对差一些了，你就得分表了。
    　　分表是啥意思？就是把一个表的数据放到多个表中，然后查询的时候你就查一个表。比如按照用户 id 来分表，将一个用户的数据就放在一个表中。然后操作的时候你对一个用户就操作那个表就好了。这样可以控制每个表的数据量在可控的范围内，比如每个表就固定在 200 万以内。

    分库
    　　分库是啥意思？就是你一个库一般我们经验而言，最多支撑到并发 2000，一定要扩容了，而且一个健康的单库并发值你最好保持在每秒 1000 左右，不要太大。那么你可以将一个库的数据拆分到多个库中，访问的时候就访问一个库好了。
    　　这就是所谓的分库分表，为啥要分库分表？你明白了吧。
    中间件 ：
        目前常用：sharding-jdbc（client 分发规则配置在配系统置文件）、
        mycat（proxy）  先在mycat官方网站上下载安装包  conf目录下编辑service.xml（主要配置mycat服务的参数，比如端口号，myact用户名和密码使用的逻辑数据库等），
                    rule.xml（主要配置路由策略，主要有分片的片键，拆分的策略 取模还是按区间划分等），schema.xml（文件主要配置数据库的信息）三个文件
        以前活跃：  cobar、 tddl 、 atlas


2。你们具体是如何对数据库进行垂直拆分或水平拆分的？

        水平拆分的意思，就是把一个表的数据给弄到多个库的多个表里去，但是每个库的表结构都一样，只不过每个库表放的数据是不同的，所有库表的数据加起来就是全部数据。
        水平拆分的意义，就是将数据均匀放更多的库里，然后用多个库来扛更高的并发，还有就是用多个库的存储容量来进行扩容。

    　　 垂直拆分的意思，就是把一个有很多字段的表给拆分成多个表，或者是多个库上去。每个库表的结构都不一样，每个库表都包含部分字段。一般来说，会将较少的访问频率很高的字段放到一个表里去，然后将较多的访问频率很低的字段放到另外一个表里去。
        因为数据库是有缓存的，你访问频率高的行字段越少，就可以在缓存里缓存更多的行，性能就越好。这个一般在表层面做的较多一些。

    两种分库分表的方式：

        一种是按照 range 来分，就是每个库一段连续的数据，这个一般是按比如时间范围来的，但是这种一般较少用，因为很容易产生热点问题，大量的流量都打在最新的数据上了。
        或者是按照某个字段 hash 一下均匀分散，这个较为常用。
        range 来分，好处在于说，扩容的时候很简单，因为你只要预备好，给每个月都准备一个库就可以了，到了一个新的月份的时候，自然而然，就会写新的库了；缺点，但是大部分的请求，都是访问最新的数据。实际生产用 range，要看场景。
        hash 分发，好处在于说，可以平均分配每个库的数据量和请求压力；坏处在于说扩容起来比较麻烦，会有一个数据迁移的过程，之前的数据需要重新计算 hash 值重新分配到不同的库或表。

3。如何不停机进行分库分表
    线上双写方案：修改系统中所有写库的代码 ，同时写入老库和新的分库分表的库，然后写个临时程序，同步老库到新库，如果发现数据冲突则检查update时间，最新数据覆盖老数据（写入分库分表中间件进行数据分发），再写个临时脚本去检查两边数据的一致性，如果没有一致则继续同步，
    最后同步完成把写入老库的代码删除重新部署，做到不停机分库分表。

4。MySQL主从复制原理
    为什么要做主从复制
        在业务复杂的系统中，有这么一个情景，有一句sql语句需要锁表，导致暂时不能使用读的服务，那么就很影响运行中的业务，使用主从复制，让主库负责写，从库负责读，这样，即使主库出现了锁表的情景，通过读从库也可以保证业务的正常运行。
        做数据的热备，主库宕机后能够及时替换主库，保证业务可用性。
        架构的扩展。业务量越来越大，I/O访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I/O访问的频率，提高单个机器的I/O性能。

    MySQL主从复制的流程 （如图：img/mysql主从复制流程.png）
        主库db的更新事件(update、insert、delete)被写到binlog
        主库创建一个binlog dump thread，把binlog的内容发送到从库
        从库启动并发起连接，连接到主库
        从库启动之后，创建一个I/O线程，读取主库传过来的binlog内容并写入到relay log
        从库启动之后，创建一个SQL线程，从relay log里面读取内容，从Exec_Master_Log_Pos位置开始执行读取到的更新事件，将更新内容写入到slave的db