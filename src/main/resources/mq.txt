-----------------------rocketmq-----------------------
使用较多，阿里开源 java语言编写 功能丰富 吞吐量十万级

成员：
    produce(生产者) comsumer(消费者)  nameServer(服务发现和路由） broker(消息存储 mq本身）
    topic主题  tag标签

mq的好处： 1 系统解偶 2 流量削峰 3 异步
    缺点：1 系统可用性降低（依赖较多，mq宕机） 2 系统复杂度提高（异步， 消息丢失，重复消费） 3 一致性问题

消息幂等（重复消费）：
    第1条的原理是，只要保持幂等性，不管来多少条重复消息，最后处理的结果都一样。
    第2条原理就是利用一张日志表来记录已经处理成功的msgId，如果新到的msgId已经在日志表中，那么就不再处理这条消息。

消息丢失（可靠性传输）：

    生产者： 可以开启confirm模式，在生产者那里设置开启confirm模式之后，你每次写的消息都会分配一个唯一的id，然后如果写入了mq中，mq会给你回传一个ack消息，告诉你说这个消息ok了。如果rabbitmq没能处理这个消息，会回调你一个nack接口，告诉你这个消息接收失败，你可以重试。
    mq   ： 开启消息持久化把消息持久化道磁盘（首先需要将os cache的异步刷盘策略改为同步刷盘，这一步需要修改Broker的配置文件，将flushDiskType改为SYNC_FLUSH同步刷盘策略，默认的是ASYNC_FLUSH异步刷盘。），就是消息写入之后会持久化到磁盘，哪怕是rabbitmq自己挂了，恢复之后会自动读取之前存储的数据，一般数据不会丢。
            设置持久化有两个步骤，第一个是创建queue的时候将其设置为持久化的，这样就可以保证rabbitmq持久化queue的元数据，但是不会持久化queue里的数据；第二个是发送消息的时候将消息的deliveryMode设置为2，就是将消息设置为持久化的，此时rabbitmq就会将消息持久化到磁盘上去。
            必须要同时设置这两个持久化才行，rabbitmq哪怕是挂了，再次重启，也会从磁盘上重启恢复queue，恢复这个queue里的数据。
            而且持久化可以跟生产者那边的confirm机制配合起来，只有消息被持久化到磁盘之后，才会通知生产者ack了，所以哪怕是在持久化到磁盘之前，rabbitmq挂了，数据丢了，生产者收不到ack，你也是可以自己重发的。
    消费者：

如何保证消息的顺序性
    rabbit：保证一个消费者对应一个quece进行顺序消费

消息积压、延时、过期失效
    积压：消息写入临时的mq，增加消费者进行消费
    过期：mq消息一般不允许设置过期时间，会给生产造成很大坑（写程序把丢失的数据查出来补回到mq进行消费）
    延时：









springboot dubbo zookeeper rocketmq id(雪花)

Apache Dubbo 提供了六大核心能力：面向接口代理的高性能RPC调用，智能容错和负载均衡，服务自动注册和发现，高度可扩展能力，运行期流量调度，可视化的服务治理与运维

