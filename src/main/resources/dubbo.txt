把原来的大块系统 ，拆分成多个子系统，子系统间互相调用，形成一个大系统的整体。

1。为什么要系统拆分 怎么拆的 拆后不用dubbo可以吗
    1）.为什么进行拆分
        ①项目过于庞大维护困难。
        如果系统过去庞大，那么代码会有很多，达到几十万行上百行，这样就需要很多人一起来维护一份代码，这样就很容易造成各种冲突，这样光合并代码就会浪费大量的时间在上面。

        ②项目发布复杂。
        一个小bug的修改发布需要整个系统全部进行重新发布，这样就很麻烦，不但发布后需要大量的测试，不管这个bug和自己负责的模块是否有关系，上线之后都要去检查，防止自己的模块被改出bug或者因为对方修改某个配置导致自己处错。

        ③项目技术升级变更麻烦。
        必须自己需要升级某个依赖的版本，那么就需要考虑到其他所有模块的依赖版本问题，几乎成为灾难。

        ④上线之后bug定位麻烦。
        由于所有的模块都在一起，bug排除会比较麻烦。

        ⑤系统无法承受高并发。
        系统单块部署，高并发无法支撑。

    2）.如何进行拆分
        大部分的系统，是要进行多轮拆分的，第一次拆分，可能就是将以前的多个模块该拆分开来了，比如说将电商系统拆分成订单系统、商品系统、采购系统、仓储系统、用户系统，等等。

        但是后面可能每个系统又变得越来越复杂了，比如说采购系统里面又分成了供应商管理系统、采购单管理系统，订单系统又拆分成了购物车系统、价格系统、订单管理系统。

        核心意思就是根据情况，先拆分一轮，后面如果系统更复杂了，可以继续分拆。

    3）.拆分后怎么通信
        ①直接基于spring mvc，纯http接口通信。

        ②使用dubbo这种rpc框架


2。说一下dubbo的工作原理 注册中心挂了后还能继续通讯吗？ rpc请求的流程
        可以通讯 有缓存信息



3。dubbo四种负载均衡策略
    1）.随机模式。按权重设置随机概率。在一个截面上碰撞的概率较高，但调用越大分布越均匀

    2）.轮询模式。按公约后的权重设置轮询比例。但存在响应慢的服务提供者会累积请求

    3）.最少活跃调用数。响应快的提供者接受越多请求，响应慢的接受越少请求

    4）.一致hash。根据服务提供者ip设置hash环，携带相同的参数总是发送的同一个服务提供者，若服务挂了，则会基于虚拟节点平摊到其他提供者上


如何基于dubbo进行服务治理、服务降级 失败重试 超时重试
    降级  mock 备用接口返回null
    retries 重试
    timeout 超时

4。如何保证分布式的幂等性（非技术问题，考经验）
    通过数据库或缓存进行记录
    1）每个请求必须有唯一id id进行记录检验

5。分布式服务接口请求的顺序性怎么保证？
    1.调用顺序
    其实分布式系统接口的调用顺序，也是个问题，一般来说是不用保证顺序的。但是有的时候可能确实是需要严格的顺序保证。
    给大家举个例子，你服务A调用服务B，先插入再删除。好，结果俩请求过去了，落在不同机器上，可能插入请求因为某些原因执行慢了一些，导致删除请求先执行了，此时因为没数据所以啥效果也没有；结果这个时候插入请求过来了，好，数据插入进去了，那就尴尬了。
    本来应该是先插入 -> 再删除，这条数据应该没了，结果现在先删除 -> 再插入，数据还存在，最后你死都想不明白是怎么回事。

    2.怎么保证
    ①首先，一般来说，从业务逻辑上最好设计系统不需要这种顺序的保证，因为一旦引入顺序性保障，会导致系统复杂度的上升，效率会降低，对于热点数据会压力过大等问题。
    ②操作串行化。
    首先使用一致性hash负载均衡策略，将同一个id的请求都分发到同一个机器上面去处理，比如订单可以根据订单id。如果处理的机器上面是多线程处理的，可以引入内存队列去处理，将相同id的请求通过hash到同一个队列当中，一个队列只对应一个处理线程。
    ③最好能将多个操作合并成一个操作。

6。 如何设计一个类似dubbo的rpc框架？ 架构上如何考虑
     1）上来你的服务就得去注册中心注册吧，你是不是得有个注册中心，保留各个服务的信心，可以用zookeeper来做，对吧

     2）然后你的消费者需要去注册中心拿对应的服务信息吧，对吧，而且每个服务可能会存在于多台机器上

     3）接着你就该发起一次请求了，咋发起？蒙圈了是吧。当然是基于动态代理了，你面向接口获取到一个动态代理，这个动态代理就是接口在本地的一个代理，然后这个代理会找到服务对应的机器地址

     4）然后找哪个机器发送请求？那肯定得有个负载均衡算法了，比如最简单的可以随机轮询是不是

     5）接着找到一台机器，就可以跟他发送请求了，第一个问题咋发送？你可以说用netty了，nio方式；第二个问题发送啥格式数据？你可以说用hessian序列化协议了，或者是别的，对吧。然后请求过去了。。

     6）服务器那边一样的，需要针对你自己的服务生成一个动态代理，监听某个网络端口了，然后代理你本地的服务代码。接收到请求的时候，就调用对应的服务代码，对吧。

7。zookeeper都有哪些使用场景
  分布式协调
  分布式锁
  元数据/配置管理
  HA高可用

8。 分布式锁的方式 如何设计
    种类
        1）redis分布式锁
        最普通： set key value NX PX 3000（多个线程抢占一把锁，key可以是同一个订单的id，给redis设置这么一个key，如果redis里面没有则返回ok，代表抢占成功，执行逻辑后释放锁；
        如果redis有这么一个key，则返回ill，代表抢占锁失败将进行重试）

        2）zookeeper分布式锁